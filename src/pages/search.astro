---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Search | SATL Lab">
  <main id="search-page" class="mx-auto max-w-3xl px-4 py-12">
    <h1 class="text-3xl font-bold">Search</h1>

    <p class="mt-2" style="color: var(--satl-text-dim);">
      블로그/노트/프로젝트/리서치 전체를 검색합니다.
    </p>

    <div class="mt-6 flex gap-2">
      <input
        id="q"
        class="satl-surface w-full rounded px-4 py-2 outline-none font-mono"
        style="color: var(--satl-text);"
        placeholder="Search…"
        autocomplete="off"
      />
      <select
        id="type"
        class="satl-surface rounded px-3 py-2 outline-none font-mono"
        style="color: var(--satl-text);"
      >
        <option value="all">all</option>
        <option value="blog">blog</option>
        <option value="notes">notes</option>
        <option value="projects">projects</option>
        <option value="research">research</option>
      </select>
    </div>

    <div id="meta" class="mt-3 text-xs font-mono" style="color: var(--satl-text-dim);"></div>

    <div id="results" class="mt-6 space-y-3"></div>
  </main>

  <script is:inline>
    const $q = document.getElementById("q");
    const $type = document.getElementById("type");
    const $results = document.getElementById("results");
    const $meta = document.getElementById("meta");

    // ── Date formatter (singleton) + cache ──
    const dtf = new Intl.DateTimeFormat("ko-KR", {
      timeZone: "Asia/Seoul",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      weekday: "short",
    });

    const dateCache = Object.create(null);
    function fmtDate(iso) {
      if (dateCache[iso]) return dateCache[iso];
      try {
        dateCache[iso] = dtf.format(new Date(iso));
      } catch {
        dateCache[iso] = iso;
      }
      return dateCache[iso];
    }

    // ── Text helpers ──
    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    // basic HTML escape for safety
    function escapeHtml(s) {
      return String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // ✅ Highlight matched tokens (safe: highlight after escaping)
    function highlight(text, tokens) {
      let safe = escapeHtml(text);
      for (let i = 0; i < tokens.length; i++) {
        const raw = tokens[i];
        if (!raw) continue;
        if (raw.length < 2) continue;

        const escaped = raw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const re = new RegExp("(" + escaped + ")", "gi");
        safe = safe.replace(
          re,
          '<mark class="bg-cyan-900/40 text-cyan-300 rounded px-0.5">$1</mark>'
        );
      }
      return safe;
    }

    // ── Data ──
    let docs = []; // SearchDoc[]
    let inv = Object.create(null); // token/prefix -> number[]
    let prepared = null; // docId -> cached normalized fields

    async function load() {
      const res = await fetch("/search-index.json", { cache: "no-cache" });
      const data = await res.json();

      docs = data.docs || [];
      inv = data.index || Object.create(null);

      prepared = new Array(docs.length);
      for (let i = 0; i < docs.length; i++) {
        const d = docs[i];
        prepared[i] = {
          type: d.type,
          ts: Date.parse(d.date) || 0,
          titleN: normalize(d.title),
          tagsN: normalize((d.tags || []).join(" ")),
          descN: normalize(d.description || ""),
          // d.text는 서버에서 이미 normalize된 값
          textN: d.text || "",
        };
      }

      $meta.textContent =
        (data.generatedAt ? "index: " + data.generatedAt + " · " : "") +
        "docs: " + docs.length;
    }

    /**
     * ✅ 후보 docId 모으기 (정석)
     * - search-index.json.ts에서 prefix 키를 미리 만들어주므로
     *   inv[t]만 조회하면 된다. (느린 for..in startsWith 제거)
     */
    function getCandidateIds(tokens) {
      const cand = new Set();

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        if (!t || t.length < 2) continue;

        const posting = inv[t];
        if (posting && posting.length) {
          for (let j = 0; j < posting.length; j++) cand.add(posting[j]);
        }
      }
      return cand;
    }

    // ── Scoring ──
    function scorePrepared(p, tokens) {
      let s = 0;
      for (let j = 0; j < tokens.length; j++) {
        const t = tokens[j];
        if (!t || t.length < 2) continue;
        if (p.titleN.indexOf(t) !== -1) s += 8;
        if (p.tagsN.indexOf(t) !== -1) s += 5;
        if (p.descN.indexOf(t) !== -1) s += 3;
        if (p.textN.indexOf(t) !== -1) s += 1;
      }
      return s;
    }

    // ── Rendering ──
    function renderDocs(list, tokens) {
      if (!list.length) {
        $results.innerHTML =
          '<div class="satl-card p-6" style="color: var(--satl-text-dim)">검색 결과가 없습니다.</div>';
        return;
      }

      const toks = tokens || [];
      const html = [];

      for (let k = 0; k < list.length; k++) {
        const d = list[k];

        const titleHtml = toks.length ? highlight(d.title, toks) : escapeHtml(d.title);
        const descHtml = d.description
          ? (toks.length ? highlight(d.description, toks) : escapeHtml(d.description))
          : "";

        const badge =
          '<span class="satl-chip" style="padding: 2px 8px; font-size: 11px;">' +
          escapeHtml(d.type) +
          "</span>";

        let tagsHtml = "";
        if (d.tags && d.tags.length) {
          const t = d.tags.slice(0, 6);
          const parts = [];
          for (let m = 0; m < t.length; m++) {
            parts.push(
              '<span class="satl-chip" style="padding: 2px 8px; font-size: 11px;">' +
                escapeHtml(t[m]) +
                "</span>"
            );
          }
          tagsHtml =
            '<div class="mt-2 flex flex-wrap gap-2">' + parts.join(" ") + "</div>";
        }

        html.push(
          '<a href="' +
            escapeHtml(d.url) +
            '" class="satl-card group relative block overflow-hidden px-5 py-4 no-underline transition">' +
            '<div class="pointer-events-none absolute inset-0 opacity-0 transition group-hover:opacity-[0.03]" ' +
              'style="background-image: linear-gradient(rgba(255,255,255,0.5) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.5) 1px, transparent 1px); background-size: 16px 16px;"></div>' +
            '<div class="relative flex items-center justify-between gap-3">' +
              '<div class="font-semibold" style="color: var(--satl-text)">' +
                titleHtml +
              "</div>" +
              badge +
            "</div>" +
            '<div class="relative mt-1 text-sm font-mono" style="color: var(--satl-text-dim)">' +
              escapeHtml(fmtDate(d.date)) +
            "</div>" +
            (descHtml
              ? '<div class="relative mt-2 text-sm" style="color: var(--satl-text-dim)">' +
                descHtml +
                "</div>"
              : "") +
            (tagsHtml ? '<div class="relative">' + tagsHtml + "</div>" : "") +
          "</a>"
        );
      }

      $results.innerHTML = html.join("");
    }

    // ── Query execution ──
    let timer = null;

    function run() {
      const q = normalize($q.value);
      const type = $type.value;

      if (!docs.length || !prepared) {
        renderDocs([], []);
        return;
      }

      // empty query: show recent (type-filtered), max 20
      if (!q) {
        const out = [];
        for (let i = 0; i < docs.length && out.length < 20; i++) {
          const d = docs[i];
          if (type !== "all" && d.type !== type) continue;
          out.push(d);
        }
        renderDocs(out, []);
        return;
      }

      const tokens = q.split(" ").filter(Boolean);

      const cand = getCandidateIds(tokens);
      const results = [];

      cand.forEach((docId) => {
        const p = prepared[docId];
        if (!p) return;
        if (type !== "all" && p.type !== type) return;

        const s = scorePrepared(p, tokens);
        if (s > 0) results.push({ s, ts: p.ts, doc: docs[docId] });
      });

      results.sort((a, b) => b.s - a.s || b.ts - a.ts);

      const out = [];
      const len = Math.min(results.length, 40);
      for (let i = 0; i < len; i++) out.push(results[i].doc);

      renderDocs(out, tokens);
    }

    function debouncedRun() {
      clearTimeout(timer);
      timer = setTimeout(run, 150);
    }

    (async function () {
      try {
        await load();

        const params = new URLSearchParams(location.search);
        $q.value = params.get("q") || "";
        $type.value = params.get("type") || "all";

        run();
      } catch (e) {
        console.error(e);
        $meta.textContent = "search index load failed";
        renderDocs([], []);
      }
    })();

    $q.addEventListener("input", debouncedRun);
    $type.addEventListener("change", run);
  </script>
</Layout>